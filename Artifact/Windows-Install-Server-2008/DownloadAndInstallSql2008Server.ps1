 Param(

    #Url du fichier de configuration
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $urlConfigurationPath,
    
    #Emplacement sur le disque apres téléchargement
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $DownloadPath,

    #Emplacement sur le disque du binaire Windows server 2008
    [ValidateNotNullOrEmpty()]
    [Parameter(Mandatory=$True)]
    [string] $BinaryPath



 )

###################################################################################################

#
# Custom Configurations
#

# Location of the log files
$ScriptLogFolder = "C:\ArtifactsLogs"
$ScriptLog = Join-Path -Path $ScriptLogFolder -ChildPath "SQLServer2008.log"


##################################################################################################

# 
# Description:
#  - Creates the folder structure which'll be used for dumping logs generated by this script and
#    the logon task.
#
# Parameters:
#  - N/A.
#
# Return:
#  - N/A.
#
# Notes:
#  - N/A.
#

function InitializeFolders
{

    if ($false -eq (Test-Path -Path $ScriptLogFolder))
    {
        New-Item -Path $ScriptLogFolder -ItemType directory | Out-Null
    }
}

##################################################################################################

# 
# Description:
#  - Writes specified string to the script log (indicated by $ScriptLog).
#
# Parameters:
#  - $message: The string to write.
#
# Return:
#  - N/A.
#
# Notes:
#  - N/A.
#

function WriteLog
{
    Param(
        <# Can be null or empty #> $message
    )

    $timestampedMessage = $("[" + [System.DateTime]::Now + "] " + $message) | % {
        Out-File -InputObject $_ -FilePath $ScriptLog -Append
    }
}



try
{
    InitializeFolders


    # some pre-condition checks
    if ([string]::IsNullOrEmpty($urlConfigurationPath))
    {
        $errMsg = $("Erreur! L'URL du ficher de configuration n'est pas spécifié.")
        WriteLog $errMsg
        Write-Error $errMsg 
    }
    if ([string]::IsNullOrEmpty($DownloadPath))
    {
        $errMsg = $("Erreur ! L'emplacement de téléchargement du fichier de configuration n'est pas spécifié.")
        WriteLog $errMsg
        Write-Error $errMsg 
    }
    if ([string]::IsNullOrEmpty($BinaryPath))
    {
        $errMsg = $("Erreur ! L'emplacement du fichier binaire de SQL Serveur n'est pas spécifié.")
        WriteLog $errMsg
        Write-Error $errMsg 
    }

   #-------------------------------------------[Telechargement du fichier en ligne]------------------------------------------ 
    WriteLog "Téléchargement du fichier de configuration:"
    WriteLog "`t $urlConfigurationPath "
    $client = new-object System.Net.WebClient 
    $client.DownloadFile($urlConfigurationPath, $DownloadPath) 

    #--------------------------------------------[Installation de Sql Server 2008 ]-------------------------------------------
    WriteLog "Installation de SQL Server 2008"
    $cmd = "'$BinaryPath' /ConfigurationFile='$DownloadPath' /Q"
    Invoke-Expression $cmd 
}
catch
{
    if (($null -ne $Error[0]) -and ($null -ne $Error[0].Exception) -and ($null -ne $Error[0].Exception.Message))
    {
        $errMsg = $Error[0].Exception.Message
        WriteLog $errMsg
        Write-Host $errMsg
    }

    # Important note: Throwing a terminating error (using $ErrorActionPreference = "stop") still returns exit 
    # code zero from the powershell script. The workaround is to use try/catch blocks and return a non-zero 
    # exit code from the catch block. 
    exit -1
}





















